---
import { getCollection, type CollectionEntry } from "astro:content";
import { ListItem } from "@bibleio/design";
import { Image } from "astro:assets";

const pages = await getCollection("handbook");

const authors = await getCollection("team");

interface FormattedPage {
	slug: string;
	title: string;
	lastUpdated?: Date;
	category?: string;
	authors: string[];
}

const formattedPages: FormattedPage[] = pages.map(
	(page: CollectionEntry<"handbook">) => {
		let slug: string;
		let title: string;
		let lastUpdated: Date | undefined;
		let category: string | undefined;
		let authors: string[];

		// Type Narrowing: Check if it's a Notion entry or a frontmatter entry
		if ("properties" in page.data) {
			// It's a Notion entry
			slug = page.data.slug.rich_text[0].plain_text;
			title = page.data.Name.title[0].plain_text;
			lastUpdated = new Date(page.data.lastUpdated?.date?.start ?? "");
			category = page.data.category?.select?.name;
			authors = page.data.author.relation.map((person: { id: string }) => {
				const matchedAuthor = authors.find(
					(author: CollectionEntry<"team">) =>
						author.data.notionUserId === person.id,
				);
				if (matchedAuthor) {
					return matchedAuthor;
				}
			});
		} else {
			// It's a frontmatter entry
			slug = page.data.slug;
			title = page.data.title;
			lastUpdated = page.data.lastUpdated
				? new Date(page.data.lastUpdated)
				: undefined;
			category = page.data.category;
			authors = page.data.authors || [];
		}

		return {
			slug,
			title,
			lastUpdated,
			category,
			authors,
		};
	},
);

for (const page of formattedPages) {
	console.log(Astro.url.pathname, "slug:", `/handbook/${page.slug}`);
}

const pagesByCategory = formattedPages.reduce(
	(acc, page) => {
		const category = page.category || "uncategorized";
		if (!acc[category]) {
			acc[category] = [];
		}
		acc[category].push(page);
		return acc;
	},
	{} as Record<string, typeof formattedPages>,
);

interface Props {
	imageCategory?: string;
}

const { imageCategory } = Astro.props;
---

<!-- TODO: This sidebar is pretty bad on mobile right now, fix it up with a dropdown menu instead of the entire list at the top
I just didn't want to change the entire thing to react right now as we're moving away very soon
-->

<div id="sidebar" class="flex sticky top-96 flex-col gap-20 w-[16rem] self-start
max-[600px]:relative max-[600px]:p-24 max-[600px]:w-full max-[600px]:top-0 max-[600px]:bg-fg-1 backdrop-blur-popup max-[600px]:border-stroke max-[600px]:border max-[600px]:rounded-16">
  <Image
    class="rounded-8 border border-stroke aspect-[2/3] w-[8.75rem] h-auto max-[600px]:hidden"
    alt={"handbook cover"}
    width={280}
    height={420}
    src={imageCategory === "organization" ? "/handbook/handbook-org.png"
      : imageCategory === "community" ? "/handbook/handbook-community.png"
      : imageCategory === "design" ? "/handbook/handbook-design.png"
      : imageCategory === "engineering" ? "/handbook/handbook-engineering.png"
      : "/handbook/handbook-org.png"}
  />
  <h2 class="text-h2 max-[600px]:hidden">Handbook</h2>
  {Object.entries(pagesByCategory).map(([category, pages]) => (
    <div class="flex flex-col gap-0 w-full">
      <div class="flex pb-6"><p class="text-body text-text opacity-75 capitalize">{category}</p></div>
      <div class="flex flex-col gap-0">
        {pages.map((page) => (
          <a
            href={`/handbook/${page.slug}`}
          >
            <ListItem text={page.title} selected={Astro.url.pathname.endsWith(`/handbook/${page.slug}`) || Astro.url.pathname.endsWith(`/handbook/${page.slug}/`)} />
          </a>
        ))}
      </div>
    </div>
  ))}
</div>
